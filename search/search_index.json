{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Glimmr Glimmr Programming language A fresh take at programming Glimmr is a new functional programming language designed to bring the elegance and power of functional programming to a wider audience. Inspired by Ocaml's strong type system, Haskell's immutability, and emphasis on pure functions, Glimmr offers a familiar syntax, making it approachable for programmers coming from other languages. What makes Glimmr unique Familiar Syntax - Glimmr adopts a syntax that's intuitive and easy to learn for programmers accustomed to mainstream languages. Powerful Type System: Glimmr boasts a robust type system that catches errors at compile time, leading to more reliable and robust applications. Pure Functional Paradigm: Glimmr encourages a declarative programming style, making your code easier to reason about, test, and parallelize. Modern Features: Glimmr incorporates modern functional programming features such as higher-order functions, currying, pattern matching, and algebraic data types, enabling you to write expressive and efficient code. Interoperability: We aim for seamless interoperability with JavaScript Who is Glimmr for? Glimmr is perfect for: Experienced programmers , Students Learning functional programming and Anyone Interested in exploring the power of functional programming with a less steep learning curve. Code Snippet import std::io { println } fn main() : Unit = println(\"Hello, world\") Get Started Dive in and explore the documentation to learn more about Glimmr's features, syntax, and standard library. Start building amazing applications today! Let's glimmr into the future of functional programming!","title":"Welcome"},{"location":"#welcome-to-glimmr","text":"","title":"Welcome to Glimmr"},{"location":"#what-makes-glimmr-unique","text":"Familiar Syntax - Glimmr adopts a syntax that's intuitive and easy to learn for programmers accustomed to mainstream languages. Powerful Type System: Glimmr boasts a robust type system that catches errors at compile time, leading to more reliable and robust applications. Pure Functional Paradigm: Glimmr encourages a declarative programming style, making your code easier to reason about, test, and parallelize. Modern Features: Glimmr incorporates modern functional programming features such as higher-order functions, currying, pattern matching, and algebraic data types, enabling you to write expressive and efficient code. Interoperability: We aim for seamless interoperability with JavaScript","title":"What makes Glimmr unique"},{"location":"#who-is-glimmr-for","text":"Glimmr is perfect for: Experienced programmers , Students Learning functional programming and Anyone Interested in exploring the power of functional programming with a less steep learning curve.","title":"Who is Glimmr for?"},{"location":"#code-snippet","text":"import std::io { println } fn main() : Unit = println(\"Hello, world\")","title":"Code Snippet"},{"location":"#get-started","text":"Dive in and explore the documentation to learn more about Glimmr's features, syntax, and standard library. Start building amazing applications today! Let's glimmr into the future of functional programming!","title":"Get Started"},{"location":"firstprogram/","text":"Hello glimmr Once again, welcome to the language reference of the glimmr programming language. If you have made it here I assume everything went well. If not, you can still follow but it is rather productive to learn practically. In this document we are going to discuss a basic glimr program, hello world. import std::io { println } // Entry point fn main() : Unit = println(\"Hello, world\") Explanation The first line import a module from the standard library and pulls the println function into the current module scope. Modules are discussed in later sections. On line 3 we can see a single line comment starting with // . On line 4 we are declaring a function named main with no arguments that returns type Unit and the body is simple a call to the println function with the string literal Hello, world passed as a parameter. Coding Paradigm It has been said a countless times at this point that glimr is a functional language. Functions are the basic blocks for building programs. You can compose functions to create complex applications. Functions also be passed to and returned from other functions. Combined with the flexible type system, this makes glimmr a great choice for developing safe applications. Coding styles Glimr is a free form language. The syntax allows you to use white space to your in your style. You can declare all expressions in a single line or separate it for readability. Observe below: Single line form fn main() : Unit = println(\"Hello, world\") VS Multi line form fn main() : Unit = println(\"Hello, world\") You will decide how you want to format your code, we do impose any coding standard or style on you. Do you. Whats next? Lets dive into our first core topic of the glimmr programming language, Literals . Lets gooo!","title":"First Program"},{"location":"firstprogram/#hello-glimmr","text":"Once again, welcome to the language reference of the glimmr programming language. If you have made it here I assume everything went well. If not, you can still follow but it is rather productive to learn practically. In this document we are going to discuss a basic glimr program, hello world. import std::io { println } // Entry point fn main() : Unit = println(\"Hello, world\")","title":"Hello glimmr"},{"location":"firstprogram/#explanation","text":"The first line import a module from the standard library and pulls the println function into the current module scope. Modules are discussed in later sections. On line 3 we can see a single line comment starting with // . On line 4 we are declaring a function named main with no arguments that returns type Unit and the body is simple a call to the println function with the string literal Hello, world passed as a parameter.","title":"Explanation"},{"location":"firstprogram/#coding-paradigm","text":"It has been said a countless times at this point that glimr is a functional language. Functions are the basic blocks for building programs. You can compose functions to create complex applications. Functions also be passed to and returned from other functions. Combined with the flexible type system, this makes glimmr a great choice for developing safe applications.","title":"Coding Paradigm"},{"location":"firstprogram/#coding-styles","text":"Glimr is a free form language. The syntax allows you to use white space to your in your style. You can declare all expressions in a single line or separate it for readability. Observe below:","title":"Coding styles"},{"location":"firstprogram/#single-line-form","text":"fn main() : Unit = println(\"Hello, world\") VS","title":"Single line form"},{"location":"firstprogram/#multi-line-form","text":"fn main() : Unit = println(\"Hello, world\") You will decide how you want to format your code, we do impose any coding standard or style on you. Do you.","title":"Multi line form"},{"location":"firstprogram/#whats-next","text":"Lets dive into our first core topic of the glimmr programming language, Literals . Lets gooo!","title":"Whats next?"},{"location":"functions/","text":"Functions Functions play an important role in functional programming, allowing developers to organize and reuse code efficiently. Functions are blocks of code that perform a specific task, taking in inputs, known as arguments or parameters, and returning outputs. Function declaration In glimmr functions are declared with the fn keyword. See the example below. fn hello() = \"hello\" fn world() = \"World\" fn space() = \" \" The functions above are simple and they all return string because of type inference. In Glimmr, the type of the returned value is inferred from the expression on the right-hand side of the equals sign, which in these cases are string literals, so the functions hello , world , and space are all inferred to return strings. This allows for concise and expressive code, without the need for explicit type annotations. You can also define functions that take arguments, allowing you to create more dynamic and reusable code. In Glimmr, function arguments are specified in parentheses after the function name, and are separated by commas. For example, you can modify the previous functions to take arguments, like this: fn greet (name: String) : String = \"hello \" ++ name fn comma_sep (a: String) (b: String) : String = a ++ \",\" ++ b fn inc x = x + 1 fn add a b = a + b fn concat a b = a ++ b Calling functions In Glimmr, you can call functions by using their name followed by the arguments in parentheses, like this: hello() , world() , or greet(\"John\") . When calling functions with multiple arguments, separate them with commas, like add(2, 3) or comma_sep(\"apple\" ,\"banana\") . The result of a function call can be used as an expression, allowing you to compose functions together to create more complex computations. For example: add(add(inc(1), 1), 3) // or concat(concat(hello(), space()), world()) Annotated Functions External Functions External functions are functions that reference code that was written in JavaScript. Bodies of external functions are not parsed so they may contain raw java script code but compiler is strict when it comes to the argument types and the return type. You are required to specify them as they cannot be inferred. The body of an external function is terminated by a ; . E.g: #[extern] fn console_log (a: a) : Unit = consoloe.log(a); //; terminates the function Exported Functions Exported functions are glimmr functions that are made public and callable from javascript code once compiled. These functions are normal glimmr functions. #[export] fn hello a = \"Hello \" ++ a What's next?","title":"Functions"},{"location":"functions/#functions","text":"Functions play an important role in functional programming, allowing developers to organize and reuse code efficiently. Functions are blocks of code that perform a specific task, taking in inputs, known as arguments or parameters, and returning outputs.","title":"Functions"},{"location":"functions/#function-declaration","text":"In glimmr functions are declared with the fn keyword. See the example below. fn hello() = \"hello\" fn world() = \"World\" fn space() = \" \" The functions above are simple and they all return string because of type inference. In Glimmr, the type of the returned value is inferred from the expression on the right-hand side of the equals sign, which in these cases are string literals, so the functions hello , world , and space are all inferred to return strings. This allows for concise and expressive code, without the need for explicit type annotations. You can also define functions that take arguments, allowing you to create more dynamic and reusable code. In Glimmr, function arguments are specified in parentheses after the function name, and are separated by commas. For example, you can modify the previous functions to take arguments, like this: fn greet (name: String) : String = \"hello \" ++ name fn comma_sep (a: String) (b: String) : String = a ++ \",\" ++ b fn inc x = x + 1 fn add a b = a + b fn concat a b = a ++ b","title":"Function declaration"},{"location":"functions/#calling-functions","text":"In Glimmr, you can call functions by using their name followed by the arguments in parentheses, like this: hello() , world() , or greet(\"John\") . When calling functions with multiple arguments, separate them with commas, like add(2, 3) or comma_sep(\"apple\" ,\"banana\") . The result of a function call can be used as an expression, allowing you to compose functions together to create more complex computations. For example: add(add(inc(1), 1), 3) // or concat(concat(hello(), space()), world())","title":"Calling functions"},{"location":"functions/#annotated-functions","text":"","title":"Annotated Functions"},{"location":"functions/#external-functions","text":"External functions are functions that reference code that was written in JavaScript. Bodies of external functions are not parsed so they may contain raw java script code but compiler is strict when it comes to the argument types and the return type. You are required to specify them as they cannot be inferred. The body of an external function is terminated by a ; . E.g: #[extern] fn console_log (a: a) : Unit = consoloe.log(a); //; terminates the function","title":"External Functions"},{"location":"functions/#exported-functions","text":"Exported functions are glimmr functions that are made public and callable from javascript code once compiled. These functions are normal glimmr functions. #[export] fn hello a = \"Hello \" ++ a","title":"Exported Functions"},{"location":"functions/#whats-next","text":"","title":"What's next?"},{"location":"inference/","text":"Type Inference Type inference is the process of automatically determining the data types of variables in a programming language. It allows developers to write code without explicitly specifying the type of every variable, making the code more concise and easier to maintain. The compiler then infers the types based on the assigned values, expressions, and usage of the variables. Glimmr supports type inference. So when calling a function or assigning a value to a variable, you don't need to specify the type explicitly. The Glimmr compiler analyzes the assigned values, expressions, and usage of the variables to automatically infer their types, allowing you to write more concise and expressive code. Type System Glimmr uses a somewhat good implementation of the Hindley-Milner type system, a well-established and widely used type inference algorithm. This type system is capable of inferring types for a wide range of programming constructs, including function calls, variable assignments, and complex expressions. The Hindley-Milner algorithm is known for its ability to infer types accurately and efficiently, making it a popular choice for functional and statically-typed programming languages. Lets look at some example expressions: 20 * 2 The above expression will have the result of type Number . Why? Because: - 20 and 2 are both numbers - * is an operator that returns Number and takes two Number expressions. (a / 2) * c The above expression will have the result of type Number . Why? Because: a is inferred to be a Number because it's being divided by 2 , which is a Number , and the / operator returns a Number . The result of (a / 2) is a Number because / returns a Number . c is inferred to be a Number because it's being multiplied by the result of (a /2) , which is a Number , and the * operator requires two Number expressions. Therefore, the result of the entire expression (a /2) * c is also a Number , as the * operator returns a Number given two Number operands. Glimmr can infer any expression, including String , List and Tuple types. What's next?","title":"Type Inference"},{"location":"inference/#type-inference","text":"Type inference is the process of automatically determining the data types of variables in a programming language. It allows developers to write code without explicitly specifying the type of every variable, making the code more concise and easier to maintain. The compiler then infers the types based on the assigned values, expressions, and usage of the variables. Glimmr supports type inference. So when calling a function or assigning a value to a variable, you don't need to specify the type explicitly. The Glimmr compiler analyzes the assigned values, expressions, and usage of the variables to automatically infer their types, allowing you to write more concise and expressive code.","title":"Type Inference"},{"location":"inference/#type-system","text":"Glimmr uses a somewhat good implementation of the Hindley-Milner type system, a well-established and widely used type inference algorithm. This type system is capable of inferring types for a wide range of programming constructs, including function calls, variable assignments, and complex expressions. The Hindley-Milner algorithm is known for its ability to infer types accurately and efficiently, making it a popular choice for functional and statically-typed programming languages. Lets look at some example expressions: 20 * 2 The above expression will have the result of type Number . Why? Because: - 20 and 2 are both numbers - * is an operator that returns Number and takes two Number expressions. (a / 2) * c The above expression will have the result of type Number . Why? Because: a is inferred to be a Number because it's being divided by 2 , which is a Number , and the / operator returns a Number . The result of (a / 2) is a Number because / returns a Number . c is inferred to be a Number because it's being multiplied by the result of (a /2) , which is a Number , and the * operator requires two Number expressions. Therefore, the result of the entire expression (a /2) * c is also a Number , as the * operator returns a Number given two Number operands. Glimmr can infer any expression, including String , List and Tuple types.","title":"Type System"},{"location":"inference/#whats-next","text":"","title":"What's next?"},{"location":"install/","text":"Get Glimmr Pre-built Binaries Glimmr is currently only available through source, pre-built binaries are not available, so in order to try out glimmr you will have to build it yourself. Luckily the build process is very simple. Follow the build steps below. Build from source To compile the glimmr compiler you have to first get the source code. $ git clone https://github.com/Glimmr-Lang/Glimmr Then run the following commands: $ cd Glimmr $ mvn package The glimr compiler should then be compiled and packaged into a .jar file that is ready to use. There is a very useful shell script on the root of the directory, named glmr , this script is the entry point of the compiler. An install script will be included in future releases. Install You can copy the glimmr folder to any place on your computer and make sure to add it to the path so that the glimmr compiler can be invoked from any working directory in the terminal. If everything went well try running the following command on your terminal. $ glmr --h If glimmr is installed properly you should see a wall of text scroll up, quickly followed by a word art created in ASCII. If not try following the build steps one more time. You can also test the installation by running the following command $ glmr --version IMPORTANT : Please note that glimmr is still a work in progress, so bugs and unfinished features are expected. If you would like to contribute to glimmr submit a pull request on github . Thank you What's next? Now that your are ready to start your glimmr journey let me not hold you back. Its coding time!","title":"Installation"},{"location":"install/#get-glimmr","text":"","title":"Get Glimmr"},{"location":"install/#pre-built-binaries","text":"Glimmr is currently only available through source, pre-built binaries are not available, so in order to try out glimmr you will have to build it yourself. Luckily the build process is very simple. Follow the build steps below.","title":"Pre-built Binaries"},{"location":"install/#build-from-source","text":"To compile the glimmr compiler you have to first get the source code. $ git clone https://github.com/Glimmr-Lang/Glimmr Then run the following commands: $ cd Glimmr $ mvn package The glimr compiler should then be compiled and packaged into a .jar file that is ready to use. There is a very useful shell script on the root of the directory, named glmr , this script is the entry point of the compiler. An install script will be included in future releases.","title":"Build from source"},{"location":"install/#install","text":"You can copy the glimmr folder to any place on your computer and make sure to add it to the path so that the glimmr compiler can be invoked from any working directory in the terminal. If everything went well try running the following command on your terminal. $ glmr --h If glimmr is installed properly you should see a wall of text scroll up, quickly followed by a word art created in ASCII. If not try following the build steps one more time. You can also test the installation by running the following command $ glmr --version IMPORTANT : Please note that glimmr is still a work in progress, so bugs and unfinished features are expected. If you would like to contribute to glimmr submit a pull request on github . Thank you","title":"Install"},{"location":"install/#whats-next","text":"Now that your are ready to start your glimmr journey let me not hold you back. Its coding time!","title":"What's next?"},{"location":"literals/","text":"Literals literals are values that are directly inserted into the code, such as numbers, strings, etc. They are exact values that are not variables and do not change during the execution of the program. Number Literals Numbers can be expressed in various formats: 20 10_000_000 50 Glimmr also supports decimal numeric literals. Similar to Integer number literals , decimal literals can also be separated by _ . 20.5 30.5 String Literals Strings allow embedding text and expressions: Basic String: \"Alice\" \"Hello, I'm a basic string\" Glimmr also supports Interpolated Strings , which can embed expressions. An interpolated string is denoted by a dollar sign ($). The expressions are enclosed in curly braces {} and can be used to embed dynamic values into the string. \"${5} * 2 = ${5 * 2}\" \"Hello ${'World'}\" Boolean Literals Boolean values are used for logical operations: true false Tuple Literals A tuple literal is represented by a sequence of values enclosed in parentheses () , with each value separated by a comma , . (1, 2, 3) (\"Hello\", 1, \"World\") Tuples are useful for grouping multiple values together, and can be used in a variety of contexts, such as function return values or data structures. List Literal List literals allow us to store multiple values of the same type in an ordered single data structure. A list literal is represented by a sequence of values enclosed in square brackets [] , with each value separated by a comma , . [1, 2, 3] [\"apple\", \"banana\", \"orange\"] Unit Literal The Unit type represents an empty value: () Comments Comments are useful for documenting code and providing context to developers. This language supports the following types of comments: Single line comments // Yow, I'm a comment Multi-line comments /* * Glimmr supports multi-line comments :) */ Comments are ignored by the compiler/interpreter and do not affect the execution of the code. What's next? Now that we've explored the basics of literals in Glimmr, we can move on to more exciting topics. In the next section, we'll delve into Glimmr data types. We'll discover how Glimmr's type system works static typing can help us avoid writing error prone programs.","title":"Literals"},{"location":"literals/#literals","text":"literals are values that are directly inserted into the code, such as numbers, strings, etc. They are exact values that are not variables and do not change during the execution of the program.","title":"Literals"},{"location":"literals/#number-literals","text":"Numbers can be expressed in various formats: 20 10_000_000 50 Glimmr also supports decimal numeric literals. Similar to Integer number literals , decimal literals can also be separated by _ . 20.5 30.5","title":"Number Literals"},{"location":"literals/#string-literals","text":"Strings allow embedding text and expressions: Basic String: \"Alice\" \"Hello, I'm a basic string\" Glimmr also supports Interpolated Strings , which can embed expressions. An interpolated string is denoted by a dollar sign ($). The expressions are enclosed in curly braces {} and can be used to embed dynamic values into the string. \"${5} * 2 = ${5 * 2}\" \"Hello ${'World'}\"","title":"String Literals"},{"location":"literals/#boolean-literals","text":"Boolean values are used for logical operations: true false","title":"Boolean Literals"},{"location":"literals/#tuple-literals","text":"A tuple literal is represented by a sequence of values enclosed in parentheses () , with each value separated by a comma , . (1, 2, 3) (\"Hello\", 1, \"World\") Tuples are useful for grouping multiple values together, and can be used in a variety of contexts, such as function return values or data structures.","title":"Tuple Literals"},{"location":"literals/#list-literal","text":"List literals allow us to store multiple values of the same type in an ordered single data structure. A list literal is represented by a sequence of values enclosed in square brackets [] , with each value separated by a comma , . [1, 2, 3] [\"apple\", \"banana\", \"orange\"]","title":"List Literal"},{"location":"literals/#unit-literal","text":"The Unit type represents an empty value: ()","title":"Unit Literal"},{"location":"literals/#comments","text":"Comments are useful for documenting code and providing context to developers. This language supports the following types of comments:","title":"Comments"},{"location":"literals/#single-line-comments","text":"// Yow, I'm a comment","title":"Single line comments"},{"location":"literals/#multi-line-comments","text":"/* * Glimmr supports multi-line comments :) */ Comments are ignored by the compiler/interpreter and do not affect the execution of the code.","title":"Multi-line comments"},{"location":"literals/#whats-next","text":"Now that we've explored the basics of literals in Glimmr, we can move on to more exciting topics. In the next section, we'll delve into Glimmr data types. We'll discover how Glimmr's type system works static typing can help us avoid writing error prone programs.","title":"What's next?"},{"location":"operators/","text":"Operators Operators are special symbols used in expressions to perform operations on values. This section covers the various operators available in Glimmr, along with examples and descriptions. Arithmetic Operators Operator Description + Adds two numbers. - Subtracts the second number from the first. * Multiplies two numbers. / Divides the first number by the second. % Returns the remainder of division. Code Snippet 2 + 3 512 % 2 Logical Operators Operator Description == Checks if two values are equal. != Checks if two values are not equal. > Checks if the first value is greater than the second. < Checks if the first value is less than the second. >= Checks if the first value is greater than or equal to the second. <= Checks if the first value is less than or equal to the second. && Checks if both operands are equal to true \u2502\u2502 Checks if one of the operands is equals to true Code Snippet 5 * 2 > 10 10 == 5 * 2 Unary Operators Operator Description ! Negates a boolean value. ~ Inverts all bits. Code Snippet !false Bitwise Operators Operator Description & Performs bitwise AND operation. ^ Performs bitwise XOR operation. >> Performs a bitwise right shift. << Performs a bitwise left shift. Code Snippet 1 << 4 1 >> ~2 String Operators Operator Description ++ Concatenates two strings. Code Snippet \"Good\" ++ \"Bye\" Pipe Operator Operator Description \u2502> Passes the result of one expression as input to another. Code Snippet \"Hello \" |> toUpperCase() |> concat(\"World\") IMPORTANT: Function calls are discussed in depth, in the functions section of this document. Dot Operator Operator Description . Accesses a property or method of an object. Code Snippet foo.bar player.pos.x What's next?","title":"Operators"},{"location":"operators/#operators","text":"Operators are special symbols used in expressions to perform operations on values. This section covers the various operators available in Glimmr, along with examples and descriptions.","title":"Operators"},{"location":"operators/#arithmetic-operators","text":"Operator Description + Adds two numbers. - Subtracts the second number from the first. * Multiplies two numbers. / Divides the first number by the second. % Returns the remainder of division.","title":"Arithmetic Operators"},{"location":"operators/#code-snippet","text":"2 + 3 512 % 2","title":"Code Snippet"},{"location":"operators/#logical-operators","text":"Operator Description == Checks if two values are equal. != Checks if two values are not equal. > Checks if the first value is greater than the second. < Checks if the first value is less than the second. >= Checks if the first value is greater than or equal to the second. <= Checks if the first value is less than or equal to the second. && Checks if both operands are equal to true \u2502\u2502 Checks if one of the operands is equals to true","title":"Logical Operators"},{"location":"operators/#code-snippet_1","text":"5 * 2 > 10 10 == 5 * 2","title":"Code Snippet"},{"location":"operators/#unary-operators","text":"Operator Description ! Negates a boolean value. ~ Inverts all bits.","title":"Unary Operators"},{"location":"operators/#code-snippet_2","text":"!false","title":"Code Snippet"},{"location":"operators/#bitwise-operators","text":"Operator Description & Performs bitwise AND operation. ^ Performs bitwise XOR operation. >> Performs a bitwise right shift. << Performs a bitwise left shift.","title":"Bitwise Operators"},{"location":"operators/#code-snippet_3","text":"1 << 4 1 >> ~2","title":"Code Snippet"},{"location":"operators/#string-operators","text":"Operator Description ++ Concatenates two strings.","title":"String Operators"},{"location":"operators/#code-snippet_4","text":"\"Good\" ++ \"Bye\"","title":"Code Snippet"},{"location":"operators/#pipe-operator","text":"Operator Description \u2502> Passes the result of one expression as input to another.","title":"Pipe Operator"},{"location":"operators/#code-snippet_5","text":"\"Hello \" |> toUpperCase() |> concat(\"World\") IMPORTANT: Function calls are discussed in depth, in the functions section of this document.","title":"Code Snippet"},{"location":"operators/#dot-operator","text":"Operator Description . Accesses a property or method of an object.","title":"Dot Operator"},{"location":"operators/#code-snippet_6","text":"foo.bar player.pos.x","title":"Code Snippet"},{"location":"operators/#whats-next","text":"","title":"What's next?"},{"location":"types/","text":"Static typing \"A statically-typed language is a language where variable types are known at compile time. In most of these languages, types must be expressly indicated by the programmer; in other cases, type inference allows the programmer to not indicate their variable types\" - Mozilla . Despite compiling down to a dynamic language ( Javascript ) glimmr is a static typed language. Static typing was chosen for glimmr during its design phase because of the I struggle thinking about code in a dynamic manner and I write better code when its typed. Supported Types Scalar Types Glimmr has support for scalar, sum and composite types (objects). For starters, lets discuss scalar types. Number Type Just like in Javascript, glimr does not separate floats from intergers. This makes the code easier to write and removes the need to constantly convert between types. Number String Type The string type allows us to store data that is human readable. For example: Natural language expressions. This allows us to write applications that display proper information to the end user. String Boolean Type The boolean type is useful for representing true or false conditions such as comparing two numbers or strings. Boolean Type Variable A type variable is a symbolic name given to a type that is not yet known. In the context of glimmr's static typing system, type variables are used to represent types that will be determined at compile time. They are often used in type inference, where the type system can automatically deduce the types of variables without explicit type annotations. a b foo Unit Type The unit type is used to represent the state of emptiness or the lack of a useful value. This is nearly equivalent to void in mainstream languages. Unit Composite Types List Type The list type represents a collection of values that can be of any type, including scalar types and other composite types. This allows for flexibility in data representation and manipulation. [Number] [String] Sum Types \"In computer programming especially functional programming and type theory, an algebraic data type*( ADT**) is a kind of composite data type, i.e., a data type formed by combining other types.\" - wikipedia. Some a Left b c None IMPORTANT: Sum types can only be instanciated via their respective literals. So the following are two different types. Some a // VS Some a b Tuple Type The tuple type allows us to to represent data finite sequences of objects that may optionally be of the same type. (String, Number, String) (Some String, Some a, Number) Object Type The object type in glimmr is a composite data type that allows for the representation of complex data structures. It is a collection of key-value pairs, where each key is an identifier and each value can be any type, including other objects. This allows for flexible and dynamic data modeling. { name: String, age: Number, isAdmin: Boolean } Union Type Union type is a type that can hold a value of any of its member types. It is a way to combine multiple types into a single type, allowing a value to be one of several types. In glimmr, union types are useful when a value can have multiple possible types, such as when working with data from an external source that may have varying types. String | Number Some a | None Note that union types can also be used with more than two types. Type Alias Type aliases allow us to name complex types and reuse them throughout our codebase. This can improve code readability and maintainability by giving meaningful names to complex type definitions. In glimmr, type aliases are defined using the type keyword followed by the type name and the type definition. type Option = Some a | None type FirstNameType = String Structural Typing In Glimmr, composite types are matched and validated structurally, meaning that two types are considered equal if they have the same structure, i.e., the same properties with the same types. This approach allows for more flexibility and expressiveness in defining complex data structures, as it enables the creation of types that are compatible with each other based on their structure, rather than requiring an exact match of their declarations. { name: String, age: Number } // is compatible with { name: String, age: Number, height: Number } What's next? In the next chapter we will look at type inference, we will explore how glimmr's type system can automatically deduce the types of variables and expressions, making it easier to write code without having to explicitly specify every type. Ready? lets get to it","title":"Types"},{"location":"types/#static-typing","text":"\"A statically-typed language is a language where variable types are known at compile time. In most of these languages, types must be expressly indicated by the programmer; in other cases, type inference allows the programmer to not indicate their variable types\" - Mozilla . Despite compiling down to a dynamic language ( Javascript ) glimmr is a static typed language. Static typing was chosen for glimmr during its design phase because of the I struggle thinking about code in a dynamic manner and I write better code when its typed.","title":"Static typing"},{"location":"types/#supported-types","text":"","title":"Supported Types"},{"location":"types/#scalar-types","text":"Glimmr has support for scalar, sum and composite types (objects). For starters, lets discuss scalar types.","title":"Scalar Types"},{"location":"types/#number-type","text":"Just like in Javascript, glimr does not separate floats from intergers. This makes the code easier to write and removes the need to constantly convert between types. Number","title":"Number Type"},{"location":"types/#string-type","text":"The string type allows us to store data that is human readable. For example: Natural language expressions. This allows us to write applications that display proper information to the end user. String","title":"String Type"},{"location":"types/#boolean-type","text":"The boolean type is useful for representing true or false conditions such as comparing two numbers or strings. Boolean","title":"Boolean Type"},{"location":"types/#type-variable","text":"A type variable is a symbolic name given to a type that is not yet known. In the context of glimmr's static typing system, type variables are used to represent types that will be determined at compile time. They are often used in type inference, where the type system can automatically deduce the types of variables without explicit type annotations. a b foo","title":"Type Variable"},{"location":"types/#unit-type","text":"The unit type is used to represent the state of emptiness or the lack of a useful value. This is nearly equivalent to void in mainstream languages. Unit","title":"Unit Type"},{"location":"types/#composite-types","text":"","title":"Composite Types"},{"location":"types/#list-type","text":"The list type represents a collection of values that can be of any type, including scalar types and other composite types. This allows for flexibility in data representation and manipulation. [Number] [String]","title":"List Type"},{"location":"types/#sum-types","text":"\"In computer programming especially functional programming and type theory, an algebraic data type*( ADT**) is a kind of composite data type, i.e., a data type formed by combining other types.\" - wikipedia. Some a Left b c None IMPORTANT: Sum types can only be instanciated via their respective literals. So the following are two different types. Some a // VS Some a b","title":"Sum Types"},{"location":"types/#tuple-type","text":"The tuple type allows us to to represent data finite sequences of objects that may optionally be of the same type. (String, Number, String) (Some String, Some a, Number)","title":"Tuple Type"},{"location":"types/#object-type","text":"The object type in glimmr is a composite data type that allows for the representation of complex data structures. It is a collection of key-value pairs, where each key is an identifier and each value can be any type, including other objects. This allows for flexible and dynamic data modeling. { name: String, age: Number, isAdmin: Boolean }","title":"Object Type"},{"location":"types/#union-type","text":"Union type is a type that can hold a value of any of its member types. It is a way to combine multiple types into a single type, allowing a value to be one of several types. In glimmr, union types are useful when a value can have multiple possible types, such as when working with data from an external source that may have varying types. String | Number Some a | None Note that union types can also be used with more than two types.","title":"Union Type"},{"location":"types/#type-alias","text":"Type aliases allow us to name complex types and reuse them throughout our codebase. This can improve code readability and maintainability by giving meaningful names to complex type definitions. In glimmr, type aliases are defined using the type keyword followed by the type name and the type definition. type Option = Some a | None type FirstNameType = String","title":"Type Alias"},{"location":"types/#structural-typing","text":"In Glimmr, composite types are matched and validated structurally, meaning that two types are considered equal if they have the same structure, i.e., the same properties with the same types. This approach allows for more flexibility and expressiveness in defining complex data structures, as it enables the creation of types that are compatible with each other based on their structure, rather than requiring an exact match of their declarations. { name: String, age: Number } // is compatible with { name: String, age: Number, height: Number }","title":"Structural Typing"},{"location":"types/#whats-next","text":"In the next chapter we will look at type inference, we will explore how glimmr's type system can automatically deduce the types of variables and expressions, making it easier to write code without having to explicitly specify every type. Ready? lets get to it","title":"What's next?"}]}