{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Glimmr Glimmr Programming language A fresh take at programming Glimmr is a new functional programming language designed to bring the elegance and power of functional programming to a wider audience. Inspired by Ocaml's strong type system, Haskell's immutability, and emphasis on pure functions, Glimmr offers a familiar syntax, making it approachable for programmers coming from other languages. What makes Glimmr unique Familiar Syntax - Glimmr adopts a syntax that's intuitive and easy to learn for programmers accustomed to mainstream languages. Powerful Type System: Glimmr boasts a robust type system that catches errors at compile time, leading to more reliable and robust applications. Pure Functional Paradigm: Glimmr encourages a declarative programming style, making your code easier to reason about, test, and parallelize. Modern Features: Glimmr incorporates modern functional programming features such as higher-order functions, currying, pattern matching, and algebraic data types, enabling you to write expressive and efficient code. Interoperability: We aim for seamless interoperability with JavaScript Who is Glimmr for? Glimmr is perfect for: Experienced programmers , Students Learning functional programming and Anyone Interested in exploring the power of functional programming with a less steep learning curve. Code Snippet import std::io { println } fn main() : Unit = println(\"Hello, world\") Get Started Dive in and explore the documentation to learn more about Glimmr's features, syntax, and standard library. Start building amazing applications today! Let's glimmr into the future of functional programming!","title":"Welcome"},{"location":"#welcome-to-glimmr","text":"","title":"Welcome to Glimmr"},{"location":"#what-makes-glimmr-unique","text":"Familiar Syntax - Glimmr adopts a syntax that's intuitive and easy to learn for programmers accustomed to mainstream languages. Powerful Type System: Glimmr boasts a robust type system that catches errors at compile time, leading to more reliable and robust applications. Pure Functional Paradigm: Glimmr encourages a declarative programming style, making your code easier to reason about, test, and parallelize. Modern Features: Glimmr incorporates modern functional programming features such as higher-order functions, currying, pattern matching, and algebraic data types, enabling you to write expressive and efficient code. Interoperability: We aim for seamless interoperability with JavaScript","title":"What makes Glimmr unique"},{"location":"#who-is-glimmr-for","text":"Glimmr is perfect for: Experienced programmers , Students Learning functional programming and Anyone Interested in exploring the power of functional programming with a less steep learning curve.","title":"Who is Glimmr for?"},{"location":"#code-snippet","text":"import std::io { println } fn main() : Unit = println(\"Hello, world\")","title":"Code Snippet"},{"location":"#get-started","text":"Dive in and explore the documentation to learn more about Glimmr's features, syntax, and standard library. Start building amazing applications today! Let's glimmr into the future of functional programming!","title":"Get Started"},{"location":"expressions/","text":"Expressions An expression is a combination of literals, operators, and variables that evaluates to a value. Expressions are used to perform calculations, comparisons, and assignments in a program. Examples of Expressions From literals , we know that literals are values that are written exactly as they are meant to be interpreted. Here are some examples of expressions that use literals: Arithmetic expressions: 2 + 3 evaluates to 5 5 - 2 evaluates to 3 4 * 5 evaluates to 20 String expressions: + \"hello\" + \" world\" evaluates to \"hello world\" From operators , we know that operators are symbols used to perform operations on values. Here are some examples of expressions that use operators: Comparison expressions: 5 > 3 evaluates to true 2 == 3 evaluates to false \"hello\" != \"goodbye\" evaluates to true Logical expressions: true && false evaluates to false true || false evaluates to true !true evaluates to false Assignment expressions: let x = 5 assigns the value 5 to the variable x let x += 2 increments the value of x by 2 Let Declarations Let declarations are used to declare and initialize variables. Here are some examples: let x = 5; declares a variable x and initializes it with the value 5 let name = \"John\"; declares a variable name and initializes it with the string \"John\" let isAdmin = true; declares a variable isAdmin and initializes it with the boolean value true From firstprogram , we can see an example of a simple program that uses expressions and let declaration to calculate the area of a rectangle. // calculate the area of a rectangle let width = 5; let height = 3; let area = width * height; In this example, the expression width * height evaluates to the product of the values of width and height , which is then assigned to the variable area .","title":"expressions"},{"location":"expressions/#expressions","text":"An expression is a combination of literals, operators, and variables that evaluates to a value. Expressions are used to perform calculations, comparisons, and assignments in a program.","title":"Expressions"},{"location":"expressions/#examples-of-expressions","text":"From literals , we know that literals are values that are written exactly as they are meant to be interpreted. Here are some examples of expressions that use literals:","title":"Examples of Expressions"},{"location":"expressions/#arithmetic-expressions","text":"2 + 3 evaluates to 5 5 - 2 evaluates to 3 4 * 5 evaluates to 20","title":"Arithmetic expressions:"},{"location":"expressions/#string-expressions","text":"+ \"hello\" + \" world\" evaluates to \"hello world\" From operators , we know that operators are symbols used to perform operations on values. Here are some examples of expressions that use operators:","title":"String expressions:"},{"location":"expressions/#comparison-expressions","text":"5 > 3 evaluates to true 2 == 3 evaluates to false \"hello\" != \"goodbye\" evaluates to true","title":"Comparison expressions:"},{"location":"expressions/#logical-expressions","text":"true && false evaluates to false true || false evaluates to true !true evaluates to false","title":"Logical expressions:"},{"location":"expressions/#assignment-expressions","text":"let x = 5 assigns the value 5 to the variable x let x += 2 increments the value of x by 2","title":"Assignment expressions:"},{"location":"expressions/#let-declarations","text":"Let declarations are used to declare and initialize variables. Here are some examples: let x = 5; declares a variable x and initializes it with the value 5 let name = \"John\"; declares a variable name and initializes it with the string \"John\" let isAdmin = true; declares a variable isAdmin and initializes it with the boolean value true From firstprogram , we can see an example of a simple program that uses expressions and let declaration to calculate the area of a rectangle. // calculate the area of a rectangle let width = 5; let height = 3; let area = width * height; In this example, the expression width * height evaluates to the product of the values of width and height , which is then assigned to the variable area .","title":"Let Declarations"},{"location":"firstprogram/","text":"Hello glimmr Once again, welcome to the language reference of the glimmr programming language. If you have made it here I assume everything went well. If not, you can still follow but it is rather productive to learn practically. In this document we are going to discuss a basic glimr program, hello world. import std::io { println } // Entry point fn main() : Unit = println(\"Hello, world\") Explanation The first line import a module from the standard library and pulls the println function into the current module scope. Modules are discussed in later sections. On line 3 we can see a single line comment starting with // . On line 4 we are declaring a function named main with no arguments that returns type Unit and the body is simple a call to the println function with the string literal Hello, world passed as a parameter. Coding Paradigm It has been said a countless times at this point that glimr is a functional language. Functions are the basic blocks for building programs. You can compose functions to create complex applications. Functions also be passed to and returned from other functions. Combined with the flexible type system, this makes glimmr a great choice for developing safe applications. Coding styles Glimr is a free form language. The syntax allows you to use white space to your in your style. You can declare all expressions in a single line or separate it for readability. Observe below: Single line form fn main() : Unit = println(\"Hello, world\") VS Multi line form fn main() : Unit = println(\"Hello, world\") You will decide how you want to format your code, we do impose any coding standard or style on you. Do you. Whats next? Lets dive into our first core topic of the glimmr programming language, Literals . Lets gooo!","title":"First Program"},{"location":"firstprogram/#hello-glimmr","text":"Once again, welcome to the language reference of the glimmr programming language. If you have made it here I assume everything went well. If not, you can still follow but it is rather productive to learn practically. In this document we are going to discuss a basic glimr program, hello world. import std::io { println } // Entry point fn main() : Unit = println(\"Hello, world\")","title":"Hello glimmr"},{"location":"firstprogram/#explanation","text":"The first line import a module from the standard library and pulls the println function into the current module scope. Modules are discussed in later sections. On line 3 we can see a single line comment starting with // . On line 4 we are declaring a function named main with no arguments that returns type Unit and the body is simple a call to the println function with the string literal Hello, world passed as a parameter.","title":"Explanation"},{"location":"firstprogram/#coding-paradigm","text":"It has been said a countless times at this point that glimr is a functional language. Functions are the basic blocks for building programs. You can compose functions to create complex applications. Functions also be passed to and returned from other functions. Combined with the flexible type system, this makes glimmr a great choice for developing safe applications.","title":"Coding Paradigm"},{"location":"firstprogram/#coding-styles","text":"Glimr is a free form language. The syntax allows you to use white space to your in your style. You can declare all expressions in a single line or separate it for readability. Observe below:","title":"Coding styles"},{"location":"firstprogram/#single-line-form","text":"fn main() : Unit = println(\"Hello, world\") VS","title":"Single line form"},{"location":"firstprogram/#multi-line-form","text":"fn main() : Unit = println(\"Hello, world\") You will decide how you want to format your code, we do impose any coding standard or style on you. Do you.","title":"Multi line form"},{"location":"firstprogram/#whats-next","text":"Lets dive into our first core topic of the glimmr programming language, Literals . Lets gooo!","title":"Whats next?"},{"location":"install/","text":"Get Glimmr Pre-built Binaries Glimmr is currently only available through source, pre-built binaries are not available, so in order to try out glimmr you will have to build it yourself. Luckily the build process is very simple. Follow the build steps below. Build from source To compile the glimmr compiler you have to first get the source code. $ git clone https://github.com/Glimmr-Lang/Glimmr Then run the following commands: $ cd Glimmr $ mvn package The glimr compiler should then be compiled and packaged into a .jar file that is ready to use. There is a very useful shell script on the root of the directory, named glmr , this script is the entry point of the compiler. An install script will be included in future releases. Install You can copy the glimmr folder to any place on your computer and make sure to add it to the path so that the glimmr compiler can be invoked from any working directory in the terminal. If everything went well try running the following command on your terminal. $ glmr --h If glimmr is installed properly you should see a wall of text scroll up, quickly followed by a word art created in ASCII. If not try following the build steps one more time. You can also test the installation by running the following command $ glmr --version IMPORTANT : Please note that glimmr is still a work in progress, so bugs and unfinished features are expected. If you would like to contribute to glimmr submit a pull request on github . Thank you What's next? Now that your are ready to start your glimmr journey let me not hold you back. Its coding time!","title":"Installation"},{"location":"install/#get-glimmr","text":"","title":"Get Glimmr"},{"location":"install/#pre-built-binaries","text":"Glimmr is currently only available through source, pre-built binaries are not available, so in order to try out glimmr you will have to build it yourself. Luckily the build process is very simple. Follow the build steps below.","title":"Pre-built Binaries"},{"location":"install/#build-from-source","text":"To compile the glimmr compiler you have to first get the source code. $ git clone https://github.com/Glimmr-Lang/Glimmr Then run the following commands: $ cd Glimmr $ mvn package The glimr compiler should then be compiled and packaged into a .jar file that is ready to use. There is a very useful shell script on the root of the directory, named glmr , this script is the entry point of the compiler. An install script will be included in future releases.","title":"Build from source"},{"location":"install/#install","text":"You can copy the glimmr folder to any place on your computer and make sure to add it to the path so that the glimmr compiler can be invoked from any working directory in the terminal. If everything went well try running the following command on your terminal. $ glmr --h If glimmr is installed properly you should see a wall of text scroll up, quickly followed by a word art created in ASCII. If not try following the build steps one more time. You can also test the installation by running the following command $ glmr --version IMPORTANT : Please note that glimmr is still a work in progress, so bugs and unfinished features are expected. If you would like to contribute to glimmr submit a pull request on github . Thank you","title":"Install"},{"location":"install/#whats-next","text":"Now that your are ready to start your glimmr journey let me not hold you back. Its coding time!","title":"What's next?"},{"location":"literals/","text":"Literals literals are values that are directly inserted into the code, such as numbers, strings, etc. They are exact values that are not variables and do not change during the execution of the program. Number Literals Numbers can be expressed in various formats: 20 10_000_000 50 Glimmr also supports decimal numeric literals. Similar to Integer number literals , decimal literals can also be separated by _ . 20.5 30.5 String Literals Strings allow embedding text and expressions: Basic String: \"Alice\" \"Hello, I'm a basic string\" Glimmr also supports Interpolated Strings , which can embed expressions. An interpolated string is denoted by a dollar sign ($). The expressions are enclosed in curly braces {} and can be used to embed dynamic values into the string. \"${5} * 2 = ${5 * 2}\" \"Hello ${'World'}\" Boolean Literals Boolean values are used for logical operations: true false Unit Literal The Unit type represents an empty value: () Comments Comments are useful for documenting code and providing context to developers. This language supports the following types of comments: Single line comments // Yow, I'm a comment Multi-line comments /* * Glimmr supports multi-line comments :) */ Comments are ignored by the compiler/interpreter and do not affect the execution of the code. What's next? Now that we've explored the basics of literals in Glimmr, we can move on to more exciting topics. In the next section, we'll delve into Glimmr data types. We'll discover how Glimmr's type system works static typing can help us avoid writing error prone programs.","title":"Literals"},{"location":"literals/#literals","text":"literals are values that are directly inserted into the code, such as numbers, strings, etc. They are exact values that are not variables and do not change during the execution of the program.","title":"Literals"},{"location":"literals/#number-literals","text":"Numbers can be expressed in various formats: 20 10_000_000 50 Glimmr also supports decimal numeric literals. Similar to Integer number literals , decimal literals can also be separated by _ . 20.5 30.5","title":"Number Literals"},{"location":"literals/#string-literals","text":"Strings allow embedding text and expressions: Basic String: \"Alice\" \"Hello, I'm a basic string\" Glimmr also supports Interpolated Strings , which can embed expressions. An interpolated string is denoted by a dollar sign ($). The expressions are enclosed in curly braces {} and can be used to embed dynamic values into the string. \"${5} * 2 = ${5 * 2}\" \"Hello ${'World'}\"","title":"String Literals"},{"location":"literals/#boolean-literals","text":"Boolean values are used for logical operations: true false","title":"Boolean Literals"},{"location":"literals/#unit-literal","text":"The Unit type represents an empty value: ()","title":"Unit Literal"},{"location":"literals/#comments","text":"Comments are useful for documenting code and providing context to developers. This language supports the following types of comments:","title":"Comments"},{"location":"literals/#single-line-comments","text":"// Yow, I'm a comment","title":"Single line comments"},{"location":"literals/#multi-line-comments","text":"/* * Glimmr supports multi-line comments :) */ Comments are ignored by the compiler/interpreter and do not affect the execution of the code.","title":"Multi-line comments"},{"location":"literals/#whats-next","text":"Now that we've explored the basics of literals in Glimmr, we can move on to more exciting topics. In the next section, we'll delve into Glimmr data types. We'll discover how Glimmr's type system works static typing can help us avoid writing error prone programs.","title":"What's next?"},{"location":"operators/","text":"Operators Operators are special symbols used in expressions to perform operations on values. This section covers the various operators available in Glimmr, along with examples and descriptions. Arithmetic Operators Operator Description Example Result + Adds two numbers. 2 + 3 5 - Subtracts the second number from the first. 5 - 2 3 * Multiplies two numbers. 5 * 2 10 / Divides the first number by the second. 10 / 2 5 % Returns the remainder of division. 10 % 3 1 Comparison Operators Operator Description Example Result == Checks if two values are equal. 5 == 5 true != Checks if two values are not equal. 5 != 2 true > Checks if the first value is greater than the second. 5 > 2 true < Checks if the first value is less than the second. 2 < 5 true >= Checks if the first value is greater than or equal to the second. 5 >= 5 true <= Checks if the first value is less than or equal to the second. 2 <= 5 true Logical Operators Operator Description Example Result && Returns true if both conditions are true. true && true true ! Negates a boolean value. !true false Bitwise Operators Operator Description Example Result & Performs bitwise AND operation. 5 & 3 1 ^ Performs bitwise XOR operation. 5 ^ 3 6 ~ Inverts all bits. ~5 -6 >> Performs a bitwise right shift. 8 >> 2 2 << Performs a bitwise left shift. 2 << 3 16 String Operators Operator Description Example Result + Combines two strings into one. \"Hello\" + \"World\" \"HelloWorld\" == Checks if two strings are identical. \"Hello\" == \"Hello\" true != Checks if two strings are different. \"Hello\" != \"World\" true ++ Concatenates two strings. \"Good\" ++ \"Bye\" \"GoodBye\" Pipe Operator Operator Description Example Result \\|> Passes the result of one expression as input to another. \"Hello\" \\|> \"${'World'}\" \"HelloWorld\" Dot Operator Operator Description Example Result . Accesses a property or method of an object. object.property Value of property","title":"operators"},{"location":"operators/#operators","text":"Operators are special symbols used in expressions to perform operations on values. This section covers the various operators available in Glimmr, along with examples and descriptions.","title":"Operators"},{"location":"operators/#arithmetic-operators","text":"Operator Description Example Result + Adds two numbers. 2 + 3 5 - Subtracts the second number from the first. 5 - 2 3 * Multiplies two numbers. 5 * 2 10 / Divides the first number by the second. 10 / 2 5 % Returns the remainder of division. 10 % 3 1","title":"Arithmetic Operators"},{"location":"operators/#comparison-operators","text":"Operator Description Example Result == Checks if two values are equal. 5 == 5 true != Checks if two values are not equal. 5 != 2 true > Checks if the first value is greater than the second. 5 > 2 true < Checks if the first value is less than the second. 2 < 5 true >= Checks if the first value is greater than or equal to the second. 5 >= 5 true <= Checks if the first value is less than or equal to the second. 2 <= 5 true","title":"Comparison Operators"},{"location":"operators/#logical-operators","text":"Operator Description Example Result && Returns true if both conditions are true. true && true true ! Negates a boolean value. !true false","title":"Logical Operators"},{"location":"operators/#bitwise-operators","text":"Operator Description Example Result & Performs bitwise AND operation. 5 & 3 1 ^ Performs bitwise XOR operation. 5 ^ 3 6 ~ Inverts all bits. ~5 -6 >> Performs a bitwise right shift. 8 >> 2 2 << Performs a bitwise left shift. 2 << 3 16","title":"Bitwise Operators"},{"location":"operators/#string-operators","text":"Operator Description Example Result + Combines two strings into one. \"Hello\" + \"World\" \"HelloWorld\" == Checks if two strings are identical. \"Hello\" == \"Hello\" true != Checks if two strings are different. \"Hello\" != \"World\" true ++ Concatenates two strings. \"Good\" ++ \"Bye\" \"GoodBye\"","title":"String Operators"},{"location":"operators/#pipe-operator","text":"Operator Description Example Result \\|> Passes the result of one expression as input to another. \"Hello\" \\|> \"${'World'}\" \"HelloWorld\"","title":"Pipe Operator"},{"location":"operators/#dot-operator","text":"Operator Description Example Result . Accesses a property or method of an object. object.property Value of property","title":"Dot Operator"}]}